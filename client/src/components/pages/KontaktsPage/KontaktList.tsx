import React, { useEffect }            from 'react';
import { useThunks, useTypedSelector } from '../../../redux';
import { Icon, Spinner }               from '../../shared';


/* =============================================================================

============================================================================= */


export function KontaktList(){
  const { dispatch, thunks: { getKontakts, deleteKontakt } } = useThunks();
  const { 
    kontakts, 
    kontaktsError, 
    loadingKontakts, 
    deletingKontakt, 
    deletingKontaktError // eslint-disable-line
  } = useTypedSelector(state => state.kontakts); 


  /* ======================

  ====================== */


  const handleDeleteKontakt = (id: number) => {
    if (deletingKontakt){ return; }
    if (!window.confirm('Are you sure?')){ return; } 

    dispatch(deleteKontakt(id)).unwrap().then(result => {
      console.log(result);
    })
    .catch(err => {
      console.log("An error occurred.", err);
    });
  };


  /* ======================

  ====================== */
  ////////////////////////////////////////////////////////////////////////////////////
  //
  //  Gotcha: If you get to the .then() block, it doesn't necessarily imply success.
  //
  //    https://redux-toolkit.js.org/api/createAsyncThunk#unwrapping-result-actions
  //    The thunks generated by createAsyncThunk will always return a resolved Promise 
  //    with either the fulfilled action object or rejected action object inside, as appropriate.
  //
  //
  //  Assuming we don't .unwrap() before .then() this means that even rejected Promises will go
  //  to .then(), and that .catch() will NEVER be invoked. More importantly, it means that we
  //  can't assume success just because we reached a .then() block.
  //
  //    If fulfilled then you get: {                 meta: { ... }, payload: data,      type: "kontakts/getKontakts/fulfilled" }
  //    If rejected then you get:  { error: { ... }, meta: { ... }, payload: undefined, type: "kontakts/getKontakts/rejected"  }
  //
  //
  //  Thus if you need to conditionally act on the outcome of an API response from 
  //  a thunk function, you'll have to check for the presence of result.error,
  //  and because it's not guaranteed, you'll have to use type guards.
  //  Alternatively, one could also parse the type string and look for "fulfilled"/"rejected".
  //
  ///////////////////
  //   
  //  If all of this seems like a huge pain, then you're in luck!
  //  Redux Toolkit also provides a .unwrap() method that you can chain 
  //  after .dispatch() and before .then().  When unwrapped the Promise behaves much 
  //  more intuitively.
  //  
  //    If fulfilled and unwrapped, then you get: payload
  //    If rejected  and unwrapped, then it goes to the catch block with err.
  //
  //
  //  Conclusion: ALWAYS CALL .unwrap() before .then() 
  //
  ////////////////////////////////////////////////////////////////////////////////////


  useEffect(() => { 
    // https://redux-toolkit.js.org/api/createAsyncThunk#unwrapping-result-actions
    dispatch(getKontakts()).unwrap().then(result => {
      // console.log("result", result); 
    })
    .catch(err => {
      console.log("An error occurred.", err);
    });
  }, [dispatch, getKontakts]);


  /* ======================

  ====================== */


  const renderKontakts = () => {
    if (kontaktsError){
      return <div className="my-5 fs-5 font-montserrat text-center text-red">{ kontaktsError.message }</div>;
    }

    // Will show stale contacts while loading new contacts in background.
    if (loadingKontakts && kontakts.length === 0){
      return (
        <Spinner 
          size={75} 
          variant="pink" 
          style={{ filter: 'drop-shadow(0px 1px 1px rgba(0,0,0,0.5))' }} 
          containerClassName="d-inline-block"
          containerStyle={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 100 }}
          useContainer={false}
        />
      );
    }

    if (kontakts.length === 0){
      return <div className="my-5 fs-5 font-montserrat text-center text-red">You seem to have no contacts...</div>;
    }

    if (kontakts.length > 0){
      return (
        <ul className="list-group mx-auto mb-5" style={{ maxWidth: 400 }}>
          {
            kontakts.map(kontakt => {
              return (
                <li key={kontakt.id} className="d-flex position-relative list-group-item mb-3 p-0 bg-light border border-blue rounded-3 shadow-sm">
                  <div className="p-3 text-blue">
                    <svg width="50" height="50" fill="currentColor" viewBox="0 0 16 16">
                      <path d="M11 6a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/>
                      <path fillRule="evenodd" d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm8-7a7 7 0 0 0-5.468 11.37C3.242 11.226 4.805 10 8 10s4.757 1.225 5.468 2.37A7 7 0 0 0 8 1z"/>
                    </svg>
                  </div>
                  
        
                  <div className="flex-1 d-flex flex-column justify-content-center">
                    <div className="text-blue font-montserrat">
                      <Icon name="person" className="me-2" />
                      {kontakt.name}
                    </div>
      
      
                    <div className="text-blue font-montserrat">   
                      <Icon name="telephone" className="me-2" />   
                      {kontakt.phone}
                    </div>


                    <button 
                      className="btn m-0 p-0 text-red" 
                      style={{ position: 'absolute', top: 5, right: 5 }}
                      onClick={() => handleDeleteKontakt(kontakt.id as number)}
                      // Important in order to avoid multiple simultaneous deletions,
                      // which is not how the reducer is set up to handle.
                      disabled={deletingKontakt} 
                    >
                      <Icon name="trash" className="d-block" style={{ lineHeight: 1 }} />
                    </button>
                  </div>
                </li>
              );
            })
          }
        </ul>
      );
    }

    return null;
  };


  return (
    <React.Fragment>
      { renderKontakts() }
    </React.Fragment>
  );
}
